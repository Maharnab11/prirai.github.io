<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is
The GNU C Library Reference Manual, for version
2.32.

Copyright (C) 1993-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Exponents and Logarithms (The GNU C Library)</title>

<meta name="description" content="Exponents and Logarithms (The GNU C Library)">
<meta name="keywords" content="Exponents and Logarithms (The GNU C Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Mathematics.html" rel="up" title="Mathematics">
<link href="Hyperbolic-Functions.html" rel="next" title="Hyperbolic Functions">
<link href="Inverse-Trig-Functions.html" rel="prev" title="Inverse Trig Functions">
 <link rel="stylesheet" href="../bookstyle.css" type="text/css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css"> <style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Exponents-and-Logarithms"></span><div class="header">
<p>
Next: <a href="Hyperbolic-Functions.html" accesskey="n" rel="next">Hyperbolic Functions</a>, Previous: <a href="Inverse-Trig-Functions.html" accesskey="p" rel="prev">Inverse Trig Functions</a>, Up: <a href="Mathematics.html" accesskey="u" rel="up">Mathematics</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Exponentiation-and-Logarithms"></span><h3 class="section">19.4 Exponentiation and Logarithms</h3>
<span id="index-exponentiation-functions"></span>
<span id="index-power-functions"></span>
<span id="index-logarithm-functions"></span>

<dl>
<dt id="index-exp">Function: <em>double</em> <strong>exp</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-expf">Function: <em>float</em> <strong>expf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-expl">Function: <em>long double</em> <strong>expl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-expfN">Function: <em>_FloatN</em> <strong>expfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-expfNx">Function: <em>_FloatNx</em> <strong>expfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>e</code> (the base of natural logarithms) raised
to the power <var>x</var>.
</p>
<p>If the magnitude of the result is too large to be representable,
<code>exp</code> signals overflow.
</p></dd></dl>

<dl>
<dt id="index-exp2">Function: <em>double</em> <strong>exp2</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-exp2f">Function: <em>float</em> <strong>exp2f</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-exp2l">Function: <em>long double</em> <strong>exp2l</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-exp2fN">Function: <em>_FloatN</em> <strong>exp2fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-exp2fNx">Function: <em>_FloatNx</em> <strong>exp2fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>2</code> raised to the power <var>x</var>.
Mathematically, <code>exp2 (x)</code> is the same as <code>exp (x * log (2))</code>.
</p></dd></dl>

<dl>
<dt id="index-exp10">Function: <em>double</em> <strong>exp10</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-exp10f">Function: <em>float</em> <strong>exp10f</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-exp10l">Function: <em>long double</em> <strong>exp10l</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-exp10fN">Function: <em>_FloatN</em> <strong>exp10fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-exp10fNx">Function: <em>_FloatNx</em> <strong>exp10fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>10</code> raised to the power <var>x</var>.
Mathematically, <code>exp10 (x)</code> is the same as <code>exp (x * log (10))</code>.
</p>
<p>The <code>exp10</code> functions are from TS 18661-4:2015.
</p></dd></dl>


<dl>
<dt id="index-log">Function: <em>double</em> <strong>log</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-logf">Function: <em>float</em> <strong>logf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-logl">Function: <em>long double</em> <strong>logl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-logfN">Function: <em>_FloatN</em> <strong>logfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-logfNx">Function: <em>_FloatNx</em> <strong>logfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions compute the natural logarithm of <var>x</var>.  <code>exp (log
(<var>x</var>))</code> equals <var>x</var>, exactly in mathematics and approximately in
C.
</p>
<p>If <var>x</var> is negative, <code>log</code> signals a domain error.  If <var>x</var>
is zero, it returns negative infinity; if <var>x</var> is too close to zero,
it may signal overflow.
</p></dd></dl>

<dl>
<dt id="index-log10">Function: <em>double</em> <strong>log10</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-log10f">Function: <em>float</em> <strong>log10f</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-log10l">Function: <em>long double</em> <strong>log10l</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-log10fN">Function: <em>_FloatN</em> <strong>log10fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-log10fNx">Function: <em>_FloatNx</em> <strong>log10fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base-10 logarithm of <var>x</var>.
<code>log10 (<var>x</var>)</code> equals <code>log (<var>x</var>) / log (10)</code>.
</p>
</dd></dl>

<dl>
<dt id="index-log2">Function: <em>double</em> <strong>log2</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-log2f">Function: <em>float</em> <strong>log2f</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-log2l">Function: <em>long double</em> <strong>log2l</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-log2fN">Function: <em>_FloatN</em> <strong>log2fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-log2fNx">Function: <em>_FloatNx</em> <strong>log2fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base-2 logarithm of <var>x</var>.
<code>log2 (<var>x</var>)</code> equals <code>log (<var>x</var>) / log (2)</code>.
</p></dd></dl>

<dl>
<dt id="index-logb">Function: <em>double</em> <strong>logb</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-logbf">Function: <em>float</em> <strong>logbf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-logbl">Function: <em>long double</em> <strong>logbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-logbfN">Function: <em>_FloatN</em> <strong>logbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-logbfNx">Function: <em>_FloatNx</em> <strong>logbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions extract the exponent of <var>x</var> and return it as a
floating-point value.  If <code>FLT_RADIX</code> is two, <code>logb</code> is equal
to <code>floor (log2 (x))</code>, except it&rsquo;s probably faster.
</p>
<p>If <var>x</var> is de-normalized, <code>logb</code> returns the exponent <var>x</var>
would have if it were normalized.  If <var>x</var> is infinity (positive or
negative), <code>logb</code> returns <em>&#x221E;</em>.  If <var>x</var> is zero,
<code>logb</code> returns <em>&#x221E;</em>.  It does not signal.
</p></dd></dl>

<dl>
<dt id="index-ilogb">Function: <em>int</em> <strong>ilogb</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-ilogbf">Function: <em>int</em> <strong>ilogbf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-ilogbl">Function: <em>int</em> <strong>ilogbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-ilogbfN">Function: <em>int</em> <strong>ilogbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-ilogbfNx">Function: <em>int</em> <strong>ilogbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dt id="index-llogb">Function: <em>long int</em> <strong>llogb</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-llogbf">Function: <em>long int</em> <strong>llogbf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-llogbl">Function: <em>long int</em> <strong>llogbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-llogbfN">Function: <em>long int</em> <strong>llogbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-llogbfNx">Function: <em>long int</em> <strong>llogbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>




<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions are equivalent to the corresponding <code>logb</code>
functions except that they return signed integer values.  The
<code>ilogb</code>, <code>ilogbf</code>, and <code>ilogbl</code> functions are from ISO
C99; the <code>llogb</code>, <code>llogbf</code>, <code>llogbl</code> functions are from
TS 18661-1:2014; the <code>ilogbfN</code>, <code>ilogbfNx</code>, <code>llogbfN</code>,
and <code>llogbfNx</code> functions are from TS 18661-3:2015.
</p></dd></dl>

<p>Since integers cannot represent infinity and NaN, <code>ilogb</code> instead
returns an integer that can&rsquo;t be the exponent of a normal floating-point
number.  <samp>math.h</samp> defines constants so you can check for this.
</p>
<dl>
<dt id="index-FP_005fILOGB0">Macro: <em>int</em> <strong>FP_ILOGB0</strong></dt>
<dd>
<p><code>ilogb</code> returns this value if its argument is <code>0</code>.  The
numeric value is either <code>INT_MIN</code> or <code>-INT_MAX</code>.
</p>
<p>This macro is defined in ISO&nbsp;C99<!-- /@w -->.
</p></dd></dl>

<dl>
<dt id="index-FP_005fLLOGB0">Macro: <em>long int</em> <strong>FP_LLOGB0</strong></dt>
<dd>
<p><code>llogb</code> returns this value if its argument is <code>0</code>.  The
numeric value is either <code>LONG_MIN</code> or <code>-LONG_MAX</code>.
</p>
<p>This macro is defined in TS 18661-1:2014.
</p></dd></dl>

<dl>
<dt id="index-FP_005fILOGBNAN">Macro: <em>int</em> <strong>FP_ILOGBNAN</strong></dt>
<dd>
<p><code>ilogb</code> returns this value if its argument is <code>NaN</code>.  The
numeric value is either <code>INT_MIN</code> or <code>INT_MAX</code>.
</p>
<p>This macro is defined in ISO&nbsp;C99<!-- /@w -->.
</p></dd></dl>

<dl>
<dt id="index-FP_005fLLOGBNAN">Macro: <em>long int</em> <strong>FP_LLOGBNAN</strong></dt>
<dd>
<p><code>llogb</code> returns this value if its argument is <code>NaN</code>.  The
numeric value is either <code>LONG_MIN</code> or <code>LONG_MAX</code>.
</p>
<p>This macro is defined in TS 18661-1:2014.
</p></dd></dl>

<p>These values are system specific.  They might even be the same.  The
proper way to test the result of <code>ilogb</code> is as follows:
</p>
<div class="example">
<pre class="example">i = ilogb (f);
if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
  {
    if (isnan (f))
      {
        /* <span class="roman">Handle NaN.</span>  */
      }
    else if (f  == 0.0)
      {
        /* <span class="roman">Handle 0.0.</span>  */
      }
    else
      {
        /* <span class="roman">Some other value with large exponent,</span>
           <span class="roman">perhaps +Inf.</span>  */
      }
  }
</pre></div>

<dl>
<dt id="index-pow">Function: <em>double</em> <strong>pow</strong> <em>(double <var>base</var>, double <var>power</var>)</em></dt>
<dt id="index-powf">Function: <em>float</em> <strong>powf</strong> <em>(float <var>base</var>, float <var>power</var>)</em></dt>
<dt id="index-powl">Function: <em>long double</em> <strong>powl</strong> <em>(long double <var>base</var>, long double <var>power</var>)</em></dt>
<dt id="index-powfN">Function: <em>_FloatN</em> <strong>powfN</strong> <em>(_Float<var>N</var> <var>base</var>, _Float<var>N</var> <var>power</var>)</em></dt>
<dt id="index-powfNx">Function: <em>_FloatNx</em> <strong>powfNx</strong> <em>(_Float<var>N</var>x <var>base</var>, _Float<var>N</var>x <var>power</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These are general exponentiation functions, returning <var>base</var> raised
to <var>power</var>.
</p>
<p>Mathematically, <code>pow</code> would return a complex number when <var>base</var>
is negative and <var>power</var> is not an integral value.  <code>pow</code> can&rsquo;t
do that, so instead it signals a domain error. <code>pow</code> may also
underflow or overflow the destination type.
</p></dd></dl>

<span id="index-square-root-function"></span>
<dl>
<dt id="index-sqrt">Function: <em>double</em> <strong>sqrt</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-sqrtf">Function: <em>float</em> <strong>sqrtf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-sqrtl">Function: <em>long double</em> <strong>sqrtl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-sqrtfN">Function: <em>_FloatN</em> <strong>sqrtfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-sqrtfNx">Function: <em>_FloatNx</em> <strong>sqrtfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the nonnegative square root of <var>x</var>.
</p>
<p>If <var>x</var> is negative, <code>sqrt</code> signals a domain error.
Mathematically, it should return a complex number.
</p></dd></dl>

<span id="index-cube-root-function"></span>
<dl>
<dt id="index-cbrt">Function: <em>double</em> <strong>cbrt</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-cbrtf">Function: <em>float</em> <strong>cbrtf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-cbrtl">Function: <em>long double</em> <strong>cbrtl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-cbrtfN">Function: <em>_FloatN</em> <strong>cbrtfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-cbrtfNx">Function: <em>_FloatNx</em> <strong>cbrtfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the cube root of <var>x</var>.  They cannot
fail; every representable real value has a representable real cube root.
</p></dd></dl>

<dl>
<dt id="index-hypot">Function: <em>double</em> <strong>hypot</strong> <em>(double <var>x</var>, double <var>y</var>)</em></dt>
<dt id="index-hypotf">Function: <em>float</em> <strong>hypotf</strong> <em>(float <var>x</var>, float <var>y</var>)</em></dt>
<dt id="index-hypotl">Function: <em>long double</em> <strong>hypotl</strong> <em>(long double <var>x</var>, long double <var>y</var>)</em></dt>
<dt id="index-hypotfN">Function: <em>_FloatN</em> <strong>hypotfN</strong> <em>(_Float<var>N</var> <var>x</var>, _Float<var>N</var> <var>y</var>)</em></dt>
<dt id="index-hypotfNx">Function: <em>_FloatNx</em> <strong>hypotfNx</strong> <em>(_Float<var>N</var>x <var>x</var>, _Float<var>N</var>x <var>y</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return <code>sqrt (<var>x</var>*<var>x</var> +
<var>y</var>*<var>y</var>)</code>.  This is the length of the hypotenuse of a right
triangle with sides of length <var>x</var> and <var>y</var>, or the distance
of the point (<var>x</var>, <var>y</var>) from the origin.  Using this function
instead of the direct formula is wise, since the error is
much smaller.  See also the function <code>cabs</code> in <a href="Absolute-Value.html">Absolute Value</a>.
</p></dd></dl>

<dl>
<dt id="index-expm1">Function: <em>double</em> <strong>expm1</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-expm1f">Function: <em>float</em> <strong>expm1f</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-expm1l">Function: <em>long double</em> <strong>expm1l</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-expm1fN">Function: <em>_FloatN</em> <strong>expm1fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-expm1fNx">Function: <em>_FloatNx</em> <strong>expm1fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return a value equivalent to <code>exp (<var>x</var>) - 1</code>.
They are computed in a way that is accurate even if <var>x</var> is
near zero&mdash;a case where <code>exp (<var>x</var>) - 1</code> would be inaccurate owing
to subtraction of two numbers that are nearly equal.
</p></dd></dl>

<dl>
<dt id="index-log1p">Function: <em>double</em> <strong>log1p</strong> <em>(double <var>x</var>)</em></dt>
<dt id="index-log1pf">Function: <em>float</em> <strong>log1pf</strong> <em>(float <var>x</var>)</em></dt>
<dt id="index-log1pl">Function: <em>long double</em> <strong>log1pl</strong> <em>(long double <var>x</var>)</em></dt>
<dt id="index-log1pfN">Function: <em>_FloatN</em> <strong>log1pfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt id="index-log1pfNx">Function: <em>_FloatNx</em> <strong>log1pfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return a value equivalent to <code>log&nbsp;(1&nbsp;+&nbsp;<var>x</var>)</code><!-- /@w -->.
They are computed in a way that is accurate even if <var>x</var> is
near zero.
</p></dd></dl>

<span id="index-complex-exponentiation-functions"></span>
<span id="index-complex-logarithm-functions"></span>

<p>ISO&nbsp;C99<!-- /@w --> defines complex variants of some of the exponentiation and
logarithm functions.
</p>
<dl>
<dt id="index-cexp">Function: <em>complex double</em> <strong>cexp</strong> <em>(complex double <var>z</var>)</em></dt>
<dt id="index-cexpf">Function: <em>complex float</em> <strong>cexpf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt id="index-cexpl">Function: <em>complex long double</em> <strong>cexpl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt id="index-cexpfN">Function: <em>complex _FloatN</em> <strong>cexpfN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt id="index-cexpfNx">Function: <em>complex _FloatNx</em> <strong>cexpfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return <code>e</code> (the base of natural
logarithms) raised to the power of <var>z</var>.
Mathematically, this corresponds to the value
</p>
<p><em>exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))</em>
</p></dd></dl>

<dl>
<dt id="index-clog">Function: <em>complex double</em> <strong>clog</strong> <em>(complex double <var>z</var>)</em></dt>
<dt id="index-clogf">Function: <em>complex float</em> <strong>clogf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt id="index-clogl">Function: <em>complex long double</em> <strong>clogl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt id="index-clogfN">Function: <em>complex _FloatN</em> <strong>clogfN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt id="index-clogfNx">Function: <em>complex _FloatNx</em> <strong>clogfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the natural logarithm of <var>z</var>.
Mathematically, this corresponds to the value
</p>
<p><em>log (z) = log (cabs (z)) + I * carg (z)</em>
</p>
<p><code>clog</code> has a pole at 0, and will signal overflow if <var>z</var> equals
or is very close to 0.  It is well-defined for all other values of
<var>z</var>.
</p></dd></dl>


<dl>
<dt id="index-clog10">Function: <em>complex double</em> <strong>clog10</strong> <em>(complex double <var>z</var>)</em></dt>
<dt id="index-clog10f">Function: <em>complex float</em> <strong>clog10f</strong> <em>(complex float <var>z</var>)</em></dt>
<dt id="index-clog10l">Function: <em>complex long double</em> <strong>clog10l</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt id="index-clog10fN">Function: <em>complex _FloatN</em> <strong>clog10fN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt id="index-clog10fNx">Function: <em>complex _FloatNx</em> <strong>clog10fNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>
<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base 10 logarithm of the complex value
<var>z</var>.  Mathematically, this corresponds to the value
</p>
<p><em>log10 (z) = log10 (cabs (z)) + I * carg (z) / log (10)</em>
</p>
<p>All these functions, including the <code>_Float<var>N</var></code> and
<code>_Float<var>N</var>x</code> variants, are GNU extensions.
</p></dd></dl>

<dl>
<dt id="index-csqrt">Function: <em>complex double</em> <strong>csqrt</strong> <em>(complex double <var>z</var>)</em></dt>
<dt id="index-csqrtf">Function: <em>complex float</em> <strong>csqrtf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt id="index-csqrtl">Function: <em>complex long double</em> <strong>csqrtl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt id="index-csqrtfN">Function: <em>complex _FloatN</em> <strong>csqrtfN</strong> <em>(_Float<var>N</var> <var>z</var>)</em></dt>
<dt id="index-csqrtfNx">Function: <em>complex _FloatNx</em> <strong>csqrtfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return the complex square root of the argument <var>z</var>.  Unlike
the real-valued functions, they are defined for all values of <var>z</var>.
</p></dd></dl>

<dl>
<dt id="index-cpow">Function: <em>complex double</em> <strong>cpow</strong> <em>(complex double <var>base</var>, complex double <var>power</var>)</em></dt>
<dt id="index-cpowf">Function: <em>complex float</em> <strong>cpowf</strong> <em>(complex float <var>base</var>, complex float <var>power</var>)</em></dt>
<dt id="index-cpowl">Function: <em>complex long double</em> <strong>cpowl</strong> <em>(complex long double <var>base</var>, complex long double <var>power</var>)</em></dt>
<dt id="index-cpowfN">Function: <em>complex _FloatN</em> <strong>cpowfN</strong> <em>(complex _Float<var>N</var> <var>base</var>, complex _Float<var>N</var> <var>power</var>)</em></dt>
<dt id="index-cpowfNx">Function: <em>complex _FloatNx</em> <strong>cpowfNx</strong> <em>(complex _Float<var>N</var>x <var>base</var>, complex _Float<var>N</var>x <var>power</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html">POSIX Safety Concepts</a>.
</p>

<p>These functions return <var>base</var> raised to the power of
<var>power</var>.  This is equivalent to <code>cexp&nbsp;(y&nbsp;*&nbsp;clog&nbsp;(x))</code><!-- /@w -->
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Hyperbolic-Functions.html" accesskey="n" rel="next">Hyperbolic Functions</a>, Previous: <a href="Inverse-Trig-Functions.html" accesskey="p" rel="prev">Inverse Trig Functions</a>, Up: <a href="Mathematics.html" accesskey="u" rel="up">Mathematics</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
